


--------------------------------- Section 5 -------------------------------------------------------------------------

Now the time has come to create token login. we can do it in 2 ways
1. We can do it via nest js jwt and passport-jwt.
2. We can do it manually.
   we are going to do it(JWT) manually. we are doing so we want to create module ourselves and use functions like forRoot().
   Doing it this way is important because later we have to sent email to verify account. and then we have to create module.

Now, 1st we need to get token generation working and then we need to put that into the module.
So, to create to token we need to install json web token as npm i jsonwebtoken and we also have to install its types as it do not have have typescript files. So, run npm i @types/jsonwebtoken --only-dev

So, to use jwt, we are going to use sign function of jwt as,
jwt.sign({foo: 'bar'}, privateKey, {algorithm: 'RS256'});  // algorithm is optional
So, this function generates a token. So, when we give the token to the user, we 1st sign it with a private key. And this private key can be given via .env.test file. Remember that this is linked to our project in ConfigModule in app.module
now the token is passed after it is generated by this function. This token contains the {foo: 'bar'} object. This object is visible to everyone. So, user can view the data of the token but user can not update it, if he updates it then token also changes. Note: we shouldn't put sensitive info inside json web token. (we are going to put user id inside it.)
for private key we can use any string -> we are going to go on (google secret key generator) randomkeygen.com and take 256bit key. (take any)
We are going to import jsonwebtoken in user services. import * as Jwt from 'jsonwebtoken'.


        const token = jwt.sign({id: user.id}, process.env.TOKEN_SECRET); // because TOKEN_SECRET is provided in env file
    One way is to generate token as shown in aboveline

        But, we want to do it the nestJs way. So, to do that we are going to use configService.
        as TOKEN_SECRET is fetched (or mapped) in ConfigModule in app.module. so we can use config service.
        To be able to use config service in users.service we need to import configModule in the users.module.
        After importing it we are going to inject config service in our user service as

            constructor(
                @InjectRepository(User)
                private readonly users: Repository<User>,
                private readonly configService: ConfigService     // this is for config service.
            ) {}

            So, now we can generate token as,
                const token = jwt.sign({id: user.id}, this.configService.get('TOKEN_SECRET'));
            and return this token if we want the allow user to login.

Note: only by doing configmodule.forroot({}) we have configservice and we can ask for it. and we have asked it in users.service.
Eg token that we got by running login is -> eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6NCwiaWF0IjoxNjI4OTExNTkyfQ.q6gyw1J10IChefhhtoHovZVvz-YDfdMDdyX8zPvAkFY

Now, if we go to jwt.io, and paste the token there then we can see the contents inside of token. So, the jwt is not be secret, it's point is to verify that nobody modified them (authenticity)

Now, we are done with the token and now we are going to create our own module for jwt token. (Put what we did for jwt in a different module.)  So,    nest g mo jwt
There are 2 types of modules
1. static module -> eg userModule
2. dynamic module -> it is module that has some configuration on it. eg configModule has a function forroot. we pass configuration inside forRoot() as a object
   dynamic module returns static module.

   we want to do something like
   const token = this.jwt.sign()
   It is something similar to what we already have as configservice.
   So, we want jwt service that is similar to configservice.
   So, we need to create dynamicmodule for it.

So we are going to do -
1.  we are going to create a dynamic module that takes some configuration.
2. then we are going to apply those configuration options.
3. and then we are going to return a static module with the configuration that we wanted.

   For 1) we are going to get dependency injection working. i.e. want forRoot() and import this in service like configservice.

Note: when we hover over forroot of config module we find that it returns a dynamic module and forroot is a static method.
So, go to jwtModule and make a static function forRoot. It can be anything that I want.
static forRoot(): DynamicModule {} or static welcome(): DynamicModule {}
now make jwtservice -> nest g s jwt remove from providers.
remove jwtservice and providers from jwt.module and do this -

        @Module({})
        @Global()
        export class JwtModule {
            static forRoot(): DynamicModule {
                return {
                    module: JwtModule,       // name of module
                    exports: [JwtService],
                    providers: [JwtService],
                }
            }
        }
            
        Now modify our JwtService.
        For testing let's create a function hello in jwt.service and call it user.service.
        we need to inject it in users.service to be able to use it in user.service.

Now, we need to add configuration option in jwt.
to do this, we are going to create a new folder "interfaces" in jwt. and in interfaces create a file "jwt-module-options.interface.ts". in this file we do as
export interface JwtModuleOptions {
privateKey: string;
}
Now in that static forRoot function in jwt.module we do
static forRoot(options: JwtModuleOptions): DynamicModule {...}

    Now we are having an error that options are not provided. So, send options from app.module as

                JwtModule.forRoot({
                    privateKey: process.env.TOKEN_SECRET
                }),
        Now, how do we send option in jwtservice. ? we do this by using provider object.
        So, in jwt.module we are currently using 
                        providers: [JwtService],
        When we look at provider defination ( do it by clicking on providers + command key), we see that provider can be of class provider or value provider or FactoryProvider or ExistingProvider
        
        So, providers: [JwtService] is actually a shortcut for,
                providers[{
                    provide: JwtService,
                    useClass: JwtService
                }]
                because we are using class provider
        
        we can also do it like this (value provider)
                providers[{
                    provide: "BANANA",
                    useValue: "abhc"
                },
                JwtService]   // don't forget we also have to provide jwt.service
        So, now we are having a provider with name BANANA and value abhc.

                providers[{
                    provide: "BANANA",
                    useValue: options
                }, 
                JwtService]

        Now, we are going to inject BANANA in the jwt.service,
        How are we going to inject it ?
            We are going to do this the same way as we inject in user.services.
    
    constructor(
        @Inject('CONFIG_OPTIONS') private readonly options: JwtModuleOptions,
    ) {console.log(options);}


NOTE: we may get this error --
Nest can't resolve dependencies of the JwtService (?). Please make sure that the argument CONFIG_OPTIONS at index [0] is available in the JwtService context.
Potential solutions:
- If CONFIG_OPTIONS is a provider, is it part of the current JwtService?
- If CONFIG_OPTIONS is exported from a separate @Module, is that module imported within JwtService?
  @Module({
  imports: [ /* the Module containing CONFIG_OPTIONS */ ]
  })

  Then this means that JwtService is being called from somewhere without importing jwtModule. We did this mistake in users.module

Now, rename this BANANA and make it 'CONFIG_OPTIONS' and store this in jwt.constants. and import it from there to use it here. In, JWT.CONSTANTS
-- export const CONFIG_OPTIONS = 'CONFIG_OPTIONS';

Now it's time to actually replace that token line in users.service.

Now, we are giving the token to the user, now how are we going to receive the token from the user ?
So, go to user.resolver and make a new query that is going to return user that is currently logged in.
@Query(() => User)
me() {}
So, how we are going to receive the token, we are going to send it in HTTP header. And we are going to create a middle ware which is going to do ---- with this HTTP header.
Middle ware are same as in express ,that they take the request and do something with the request and call the next() funtion.

    Now, create a jwt.middleware.ts in jwt folder. And in here we do - 

            export class JwtMiddleware implements NestMiddleware {
                use(req: Request, res: Response, next: NextFunction) {
                    console.log(req.headers);
                    next();
                }
            }
    NOTE:  NextFunction, Request, Response are from "express";
    
    We can also do a function here as,
        export function jwtMiddleware(req: Request, res: Response, next: NextFunction){
            console.log(req.headers);
            next();
        }

    How to install a middle ware ?
        we can install it on 1 module or we can install it for all the modules (app.module). we are going to do for all modules.

        export class AppModule implements NestModule {
            configure(consumer: MiddlewareConsumer){
                consumer.apply(<here we put the middleware, eg - JwtMiddleware>)<.forRoutes([{<we can give option for which routes we want it>}])>
            }
        }  
                        we checked by seeing the error and then clicking on the words. Like in error we find that configure method must be defined with a consumer. we do that and then clicking on consumer we find that apply method must be defined.
        eg- 
         export class AppModule implements NestModule {
            configure(consumer: MiddlewareConsumer){
                consumer.apply(JwtMiddleware).forRoutes({
                    path: '/graphql',
                    method: RequestMethod.POST,
                });
            }
        }

    For all routes and for all methods we can do as -
        export class AppModule implements NestModule {
            configure(consumer: MiddlewareConsumer){
                consumer.apply(JwtMiddleware).forRoutes({
                    path: '*',
                    method: RequestMethod.ALL,
                });
            }
        }

    There is also a function .exclude({}) in place for forRoutes. same params as forRoutes. This is going to exclude routes from those paths and methods.

INPLACE OF DOING IT TO APP.MODULE, we can also do this in main.ts as
app.use(JwtMiddleware); in our bootstrap function. // it works only when we create middle ware in function.
So, this is kind of difference, if we do it here we are going to use it everywhere, but if we do it in app.module we have more control on where to use middleware and where not to.
Another difference is that nest js allows us dependency injection in the class only and not in function.

We are going to extract the token from header in our jwt middleware

passed from graphQl as
{
"X-JWT": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6NCwiaWF0IjoxNjI5MDAxNDg4fQ.-QwWQiwCMIE4cCsog6ZGf684M58yhSVFlnOLtc005JY"
}

in jwt.middleware
export class JwtMiddleware implements NestMiddleware {
use(req: Request, res: Response, next: NextFunction) {
if ('x-jwt' in req.headers) {
console.log(req.headers['x-jwt']);
}
next();
}

Now, we need to verify the token, so look for this jsonwebtoken on how to verify the token.
So, we saw 2 functions
1. verify -> it verifies the token and also returns the decripted payload
2. decode -> it do not verifies the token but returns the decripted payload.
   So, we are going to use verify. and we are going to do it in jwt.service as -

   verify(token: string) {
   return jwt.verify(token, this.options.privateKey);
   }
   verify returns a string or an object. So, we need to check what it return.

   Now, the problem is that how to x-jwt will be going from jwt.middleware to jwt.service.
   To do this, we need to use dependency injection. So, mark the class in jwt.middleware as @Injectable() and create a constructor in this class to get the JwtService.

   To check what verify return is what we want we do as -

                @Injectable()
                export class JwtMiddleware implements NestMiddleware {
                    constructor(private readonly jwtService: JwtService) {}
                    use(req: Request, res: Response, next: NextFunction) {
                        if ('x-jwt' in req.headers) {
                            const token = req.headers['x-jwt'];
                            const decoded = this.jwtService.verify(token.toString()); 
                                            // we do it make sure that token is sent in the form of string as verify accepts string as well as object
                            if (typeof decoded === 'object' && decoded.hasOwnProperty('id') ) {
                                console.log([decoded['id']]);
                            }
                                            // we do this typeof because we want our decoded as a payload not as a string. And we need to make sure this is done.
                                            // So, we get the id of the person who send the token. ie. logged in user.
                        }
                        next();
                    }
                }

   Now, we need to look for the user via the user id that we got from the token.
   So, we the user.service we create a function findById(id: number): User {}
   // we will use findOne function of the Repository as -
   async findById(id: number): Promise<User> {
   return this.users.findOne({ id });
   }
   We need to call this function from our jwt-middle ware. So, inject user service in jwt middleware.
   we do it in constructor.


Doing so, it gives an error as

            Potential solutions:
            - If UsersService is a provider, is it part of the current AppModule?
            - If UsersService is exported from a separate @Module, is that module imported within AppModule?
            @Module({
                imports: [ /* the Module containing UsersService */ ]
            })

As the user module is different module than jwt module. So, we are asking for a service that is inside other module. AND THAT OTHER MODULE IS NOT EXPORTING THIS SERVICE
So, to resolve it we need to export user service from user.module as --
exports: [UsersService],  // inside @module({<here>})

Now, we can call the function findById from jwtMiddleware and then we get the user that is logged in.
after getting the user we put the user in the req (in the middleware only, in next line in which we call the findById function) as-
req['user'] = user

    Now the next() will get this updated request.

Now, the task is to give this updated request to our resolvers (in graphQL module). Now we need to remember that graphQL module implements from appolo server. Appolo server has 1 property - context. Context is available for each request. When context is defined as a function it will be called on each request and it will receive an object containing a req property, which represents the request itself. So, context is what we want. This is why we put the user on the request, so that we can share the user to all our resolvers.

So, context is something in which we can put any property and then this will be available for all our resolvers. See documentation for example.

Eg -
in app.module
graphQLModule.forRoot({
context: ({req}) => ({potato: true})
})

    1st middle ware is hit then graphQl module is hit then guards is hit and then resolver is hit by the incomming requeset.

    Now, potato = true will go to all our resolvers.
    here we do context: ({req}) => ({user: req['user]},)
            Don't forget our req already has our user, we now have to put the user in context.

    So, in users.resolver, 
                @Query(() => User)
                me(@Context() context) {
                    console.log(context);
                    <here>
                }

Now, we can see that our user is in the context.
So, now in theory, we can do something like, in <here> 3-4 lines above,

        if(!context.user){
            // user not present
            return <something that signifies no user is present>
        }
        else{
            return context.user;
        }

    This works perfectly fine but the problem is that we do not want to do this on every resolver, this will create duplicate code. So, now the concept of guards come in. (nestjs documentation- guards is like a sheild which is used to stop a request.)

    Now, we need to create a new module authorization
            nest g mo auth
        This module is not important to put in app.module, so remove it from there.
        Now create a file auth.guard.ts
        It is like a function that can choose if we can continue our request or not.
        So, in auth.guard.ts we do,

        @Injectable()
        export class AuthGuard implements CanActivate { } // CanActivate is like a function that if returns true then the request will continue, and if returns false that request will stop. CanActivate interface has only 1 function canActivate and its parameter is ExecutionContext which basically provides access to Context.
        This context is not the context of GraphQL but the context of pipeline (written in comments in the interface CanActivate), basically it is request object. So, now -- 

            @Injectable()
        export class AuthGuard implements CanActivate { 
            canActivate(context: ExecutionContext){
                // console.log(context); // to look the format of context
                // return false;
            }
        }
        To use this guard we are going to do this way --
           @Query(() => boolean)
           @UseGuards(AuthGuard)

    Note: context in canActivate is in HTTP, we need to convert it to graphQl conext.
    we do, it as 
    const gqlContext = GqlExecutionContext.create(context).getContext() // inside canactivate function.
    Now, let's get the user.
    const user = gqlContext['user];
    if (!user) {
        return false;
    }

    Now, we are going to make our decorator so that we can get our user at <here>

    @Query(() => boolean)
    me(<we want user here>) {}
    Here, what we want is to know who is the one who is asking for the query, So, for this we need to create our own decorator. This decorator will behave somewhat like @Args().

So, create a file auth-user.decorator.ts in auth.
    Decorator are easy to create.

    export const <nameOfDecorator> = createParamDecorator(<factoryFunction>)   // it takes a factory function which takes
                                                                     // data: unknown value and context: ExecutionContext

So,
export const AuthUser = createParamDecorator(
(data: unknown, context: ExecutionContext) => {
const gqlContext = GqlExecutionContext.create(context).getContext();
const user = gqlContext['user'];
return user;
}
)

    Note that what we did is similar to auth.guards.
    So, to get the user in resolver we do as----

                        @Query(() => User)
                        @UseGuards(AuthGuard)
                        me(@AuthUser() authUser: User) {
                            console.log(authUser);
                            return authUser;
                        }
            Now, we get our user when we call me, and note: it works only when token is passed in http headers.

    This whole thing can be done using passport easily, doing this way is important as we want to get verificatiion mails in our next section.
    we learnt dynamic module, providers, dependency injection, middleware, guards, decorators, context just for authentication.

So, flow of request is, 1st token is sent on the HTTP headers, then request goes to the middleware, middle ware decrypts the token and verifies it and adds the user to the req object. Than that req object gets put inside graphql context, then our guard finds the graphQl context and looks for the user on the graphQl context if the user is present then it returns true and let's request to pass to resolvers. Now when the request is authorized, we need to get the user object so we create a decorator and decorator looks inside the same graphQl context and return the user.

so, we are going to create 1 query and 1 mutation.
let's go for query 1st. query is profile -> because some times we just need to get the profile of the user.
eg - 1 user wants to get the profile of other user.

let's name the query as user-profile()
So, now we need to make input and output dtos.

            import { ArgsType, Field } from "@nestjs/graphql";
            @ArgsType()
            export class UserProfileInput {
                @Field(type => Number)
                userId: number;
            }

in user.resolver

                @UseGuards(AuthGuard)
                @Query(() => User)
                userProfile(@Args() UserProfileInput: UserProfileInput) {
                    return this.userService.findById(UserProfileInput.userId);
                }

Now let's test it. it gives error - cannot query field "id" and graphQl_validation_failed.
This is because for some reason @ObjectTpye() went missing from core.entites. So, put it there on the top of core.enties class.

(at this point before adding ObjectType decorator on core.entites, I also saw query logs running in the terminal. Like we are running query again and again after 4-5 sec after.)

So, now we can do that
{
userProfile(userId: 2) {
id
email
}
}

Now this do not returns error when we do send wrong id, so we need to take core of that.
So, to resolve this we are going to make userProfileOutputDTOS. So, we are going to return ok, error, data
So, we are going to extend it from mutationOutputDTOS. mutationOutputDTOS already contains error and ok. And now we need 1 more field as user.

        in user-profile.dtos.ts

                            @ObjectType()
                            export class UserProfileOutputDTO extends CoreOutput {
                                @Field(() => User, {nullable: true})
                                user?: User;
                            }

        So, now user.resolver should return UserProfileOutputDTO.

        we update as ---
                            @UseGuards(AuthGuard)
                            @Query(() => UserProfileOutputDTO)
                            async userProfile(@Args() UserProfileInput: UserProfileInput): Promise<UserProfileOutputDTO> {
                                try{
                                const user = await this.userService.findById(UserProfileInput.userId);
                                if (!user){
                                    throw Error();
                                }
                                return {
                                    ok: true,
                                    user,
                                }
                                }
                                catch(e) {
                                    return {
                                        error: "user not found",
                                        ok: false
                                    }
                                }
                            }

            So, now we do query as

                            {
                                userProfile(userId: 2) {
                                    ok
                                    user
                                    error
                                }
                            }

Now, renaming mutationOutput to CoreOutput // because it looks cooler.
Now it's time to edit or profile
So, create a mutation for it and we need to have DTO's for it as well.
So, create a file edit-profile.dto.ts

        here, we create a class editProfileOutputDTO that extends CoreOutput {} and we make it as ObjectType()
    Now, create a mutation in users.resolver as editProfile. Edit profile will need @authUser{} and editProfileInputDTO

    Now crete a class editProfileInputDTO extends PickType(User, ['email', 'password'])
            // because we allow only email and password to update. Now we also need that some time we update email, sometime password, sometime both so we also need PartialType.
            So, we are ccombining pickType and PartialType
        And we are going to use @inputType() decorator for editProfileInputDTO class.

        Now, in resolver,
                                @UseGuards(AuthGuard)
                                @Mutation(() => editProfileOutputDTO)
                                async editProfile(
                                    @AuthUser() authUser: User, 
                                    @Args('input') editProfileInput: editProfileInputDTO
                                    ): Promise<editProfileOutputDTO> {
                                        // call service function here so 1st create service function
                                }

        Now, go to service,
                         async editProfile(userId: number, { email, password }: editProfileInputDTO) {
                            return this.users.update( { id: userId }, {email, password} );
                         }

        Now, again to resolver,
                            @UseGuards(AuthGuard)
                            @Mutation(() => editProfileOutputDTO)
                            async editProfile(
                                @AuthUser() authUser: User, 
                                @Args('input') editProfileInput: editProfileInputDTO
                                ): Promise<editProfileOutputDTO> {
                                    try {
                                        await this.userService.editProfile(authUser.id, editProfileInput);
                                        return {
                                            ok: true
                                        };

                                    }
                                    catch (error){
                                        return {
                                            ok: false,
                                            error
                                        }
                                    }
                            }

        Note: in the edit profile we are directly running update() [check editProfile in users.service], also we know that update do not checks that the data is present in the DB or not, it just sends an update query which updates if data is present or add it if the data is not present in the DB.
        We are doing this without any concern as the the user id that we are getting is from the cookies (token) and not from graphQL. So, we are making sure that the user is logged in before doing any editProfile mutation.

    Now when we run the mutation from the graphQl page, we get the error as -- "Null value in column \"password\" voilates not-null constraint"

    our mutation from graphql page is --- and we also need to provide token from HTTP headers.
                        mutation (input: {email: "abc@gmail.com"}) {ok, email}

    This means that we are giving the other value as null, So, basically this means that if you want to update email and you pass email from graphQl page and do not pass password, then password will be tried to set to null.

    To undersstand the error,
            look at our editprofileinput in resolver and console.log(input) and look at the result.
            now do console.log(email and password) in editprofile service. 
            we see that password comes as undefined here. And this is because we are using the spread syntax in editprofile service as --  { email, password }: editProfileInputDTO, so if anything is not passed then that will be assigned undefined.
            So, doing this is not the smart thing to do, instead we are going to do---
                        
                        editprofile_name_used_here: editProfileInputDTO
                So, here password = undefined is not present.
                So, we are going to do as --- 

                        async editProfile(userId: number, {editprofile_name_used_here: editProfileInputDTO) {
                            return this.users.update( { id: userId }, {...editprofile_name_used_here} );
                         }
    Note: now we try to update password, then password is not updated as hashed value. So, we need to fix it.
    So, we are going to use @BeforeUpdate() on hashPassword in user.entity to fix this.

            But this is not working. why is not working, why is our beforeInsert hook is not working? This should be working as we are calling update function of TypeOrm in our Editprofile function of users.service.
            The problem is because are calling update from users repository. Update is a very fast and efficient query which do not actually checks that the entry is present in DB or not. So, this means that we are not actually not updating the entry, we are just sending the query to the database and nothing else. And this is not going to trigger beforeinsert. As beforeinsert when we update the entry. Currently, we are just sending the query to the DB and hoping that the query works. If we call update, then hooks are not called.
         
         So, instead we are going to call 'save' method. Save -> saves all the given entities in the DB, if the entities are not present in DB then it will create them otherwise it will update them
         therefore,

                async editProfile(userId: number, {email, password}: editProfileInputDTO): Promise<User> {
                    const user = await this.users.findOne(userId);
                    if (email){
                        user.email = email;
                    }
                    if (password){
                        user.password = password;
                    }
                    return this.users.save(user);
                }

    Now, user can update email at any time, so now we need to verify the email.

async editProfile(userId: number, {email, password}: editProfileInputDTO): Promise<User> {
const user = await this.users.findOne(userId);
if (email){
// here we will be able to verify the email...............
// we will add something that will send the email to the user to verify
user.email = email;
}
if (password){
user.password = password;
}
return this.users.save(user);
}


-------------------------------- Section 6 -------------------------------------------------------------------------
Now, we want to do email verification. We are going to understand database relationships.

We are going to create our email module, it will be a dynamic module as JWT. There is also a nest js community email module.

Now create verification.entity.ts in entities in users.


We are going to do 1-1 relationship. This means that our verification entity can only have 1 user, and a user can only have 1 verification.

eg of 1-many is a restaurant can have many dishes.

Verification.entity.ts is going to have a class verification that extends CoreEntity.
And in this class we are going to have 1 addition field code. Now this code will be used to verify the email.

Now, while defining relationships we need to have a decorator @JoinColumn() and @OneToOne() that is something like foreign key. JoinColumn() is required and it must be set on 1 side of relationship. (typeorm documentation).

Eg- if I want to have a user and from the user I want to get the verifiction that the user had then I have to put @JoinColumn() on the User entity. If I want to get the verification and from the verification I want to access the user then I have to put @JoinColumn() on the verification entity.
In our case we are going to access user from them verification side, So, we want joinColumn on the verification side.

Like ---
import { Field, InputType, ObjectType } from "@nestjs/graphql";
import { string } from "joi";
import { CoreEntity } from "src/common/dtos/core.entity";
import { Column, Entity, JoinColumn, OneToOne } from "typeorm";
import { User } from "./user.entity";

                                @InputType({isAbstract: true})
                                @ObjectType()
                                @Entity()
                                export class Verification extends CoreEntity {
                                    @Column()
                                    @Field(() => string)
                                    code: string;

                                    @OneToOne(() => User)
                                    @JoinColumn()
                                    user: User;
                                }

There is no new table in our DB, because we forgot to put verification in typeOrmModule in app.module
We are going to add 1 more field to our User.entity.ts as boolean -> emailVerified. and by default it will be false.

                                @Column({default: false})
                                @Field(() => Boolean)
                                emailVerified: boolean;

Now, we want that when our user create a account, we want to verify email (i.e we want to create verification).
So, for this we need to inject a new repository Verification in users.
So, add it in user module imports. (in forFeature).
Now add in users.service (inside constructor) as ---
@InjectRepository(Verification) private readonly verify: Repository<Verification>
Now, we have a verification repository on user.service
    Now, in user.service in the createAccount, after we save the user we are going to create a verifcation and saving the user in that verification. 

                        async CreateAccount({email, password, role}: CreateAccountInputDTO)
                        : Promise<[boolean, string?]> {
                            try {
                                const exist = await this.users.findOne({email});
                                if (exist){
                                    // return error
                                    return [false, 'there is a user with this email'];
                                }
                                const new_user = await this.users.create({email, password, role});
                                const user = await this.users.save(new_user);
                                await this.verify.save(this.verify.create({user,}));
                                return [true];
                            }
                            catch(e){
                                return [false, "Couldn't create account"]
                            }
                        }
// NOTE - find the difference b/w user and new user in above code by console.log()
Now, we will get the error as we have not created "code": string for the verification. We are going to put code in verification.entity.ts

So, in class verification,
            @BeforeInsert()
            createCode(): void {
                // this.code = "random code"; we can do it using uuid. other way is to convert math.random to string.
                // Math.random().toString(<number between 2 and 36 inclusive this is base>).substring(2)
                // if we want uuid we do npm i uuid. then import it as---
                                    import {v4 as uuid} from 'uuid';
                            and use it as uuidv4();
            }

Note that, now when we createAccount a row in verification is also added.
Now, we have to do the same thing in edit profile.
                await this.verify.save(this.verify.create({user}));  // verify is the instace of verification from constructor in users.service

Now, we have a problem that we are not not deleting any verifications, that means we are not currently verifying the emails.

Now, let's do this. verification is very small thing that we are not going to create a new service for this, we are going to do this in users.module. So, go to user.resolvers.
And create a mutation as

@Mutation(() => <output that we dont have yet.>)

So, go to dtos in users and create a file verify-email.dtos.ts

and make a class VerifyEmailOutputDTO extends CoreOutput{}
and this is ObjectType()

Now create a class VerifyEmailInputDTO extends PickType(Verification, ['code']) {}
and this is InputType()

Note: currently we are getting the error - UnhandledPromiseRejectionWarning: Error: Cannot determine a GraphQL input type for the "code". Make sure your class is decorated with an appropriate decorator.

The problem that we found is that --
@Column()
@Field(() => string)
code: string;
in field decorator we are using small case 'string'. So, make it caps as 'String' and it works fine.
Now let's test --
In graphQL create a new user and lets see that verification is made for it or not ?
It's working.
Now, let's verify email as --
TypeOrm does not load relationships as this is an expensive option for typeOrm. So, we have to tell this explicitely
